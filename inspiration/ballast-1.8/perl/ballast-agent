if ($conf{data_cipher}) {
    open(FILE, $conf{key_file}) or die "Unable to load key file: $!\n";
    my $key = <FILE>;
    close FILE;

    # untaint key
    $key = $1 if ($key =~ /(.*)/);

    require Crypt::CBC;
    $conf{-cbc} = Crypt::CBC->new(
        -key => $key,
        -cipher => $conf{data_cipher},
    );
}

# collect average load and processes
if (open(FILE, "/proc/loadavg")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s+|\s+$//g;
        my @cols = split(/\s+/, $line);
        next if (scalar(@cols) != 5);
        $load{load_1} = $cols[0];
        $load{load_5} = $cols[1];
        $load{load_15} = $cols[2];
        $load{procs} = $cols[3];
        $load{procs} =~ s/.*\///;
    }
    close FILE;
}

# collect network load
if (open(FILE, "/proc/net/dev")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s+|\s+$//g;
        my @cols = split(/:|\s+/, $line);
        next if (scalar(@cols) != 17 || $cols[1] !~ /^\d+$/);
        $load{d_net_read_bytes} += $cols[1];
        $load{d_net_reads} += $cols[2];
        $load{d_net_write_bytes} += $cols[9];
        $load{d_net_writes} += $cols[10];
    }
    close FILE;
    $load{d_net_ops} = $load{d_net_reads} + $load{d_net_writes};
    $load{d_net_bytes} = $load{d_net_read_bytes} + $load{d_net_write_bytes};
}

# collect virtual memory load
if (open(FILE, "/proc/vmstat")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s+|\s+$//g;
        $load{d_page_in} += $1 if ($line =~ /^pgpgin\s+(\d+)/);
        $load{d_page_out} += $1 if ($line =~ /^pgpgout\s+(\d+)/);
        $load{d_swap_in} += $1 if ($line =~ /^pswpin\s+(\d+)/);
        $load{d_swap_out} += $1 if ($line =~ /^pswpout\s+(\d+)/);
    }
    close FILE;
}

# collect per user load if specified
if ($conf{user_load}) {
    foreach my $file (glob("/proc/[0-9]*/stat")) {
        open(FILE, $file) or next;
        my $line = <FILE>;
        close FILE;
        my @cols = split(/\s+/, $line);
        my $pid = $cols[0];
        my @stat = stat "/proc/$pid";
        my $cmd = $cols[1];
        $cmd =~ s/\s+|[{}()]//g;

        # ignore root processes that are not sshd or dropbear
        next if ($stat[4] == 0 && $cmd !~ /^(?:sshd|dropbear)$/);

        my $proc = "cmd:$cmd";
        $proc .= " cpu:" . ($cols[13] + $cols[14]);
        $proc .= " gid:$stat[5]";
        $proc .= " mem:$cols[22]";
        $proc .= " ram:$cols[23]";
        $proc .= " pid:$pid";
        $proc .= " ppid:$cols[3]";
        $proc .= " time:" .
            ($load{time} - $load{boot_time} - int($cols[21] / 100));
        $proc .= " uid:$stat[4]";

        # collect per user i/o load if available
        if (open(FILE, "/proc/$pid/io")) {
            my ($bytes, $ops);
            while (my $line = <FILE>) {
                if ($line =~ /^rchar:\s*(\d+)/) {
                    $proc .= " io_read_bytes:$1";
                    $bytes += $1;
                } elsif ($line =~ /^wchar:\s*(\d+)/) {
                    $proc .= " io_write_bytes:$1";
                    $bytes += $1;
                } elsif ($line =~ /^syscr:\s*(\d+)/) {
                    $proc .= " io_reads:$1";
                    $ops += $1;
                } elsif ($line =~ /^syscw:\s*(\d+)/) {
                    $proc .= " io_writes:$1";
                    $ops += $1;
                }
            }
            $proc .= " io_ops:$ops";
            $proc .= " io_bytes:$bytes";
        }
        $load{"pid_$pid"} = $proc;
    }
}

# untaint PATH
$ENV{PATH} = "/bin:/usr/bin:/usr/local/bin";

# execute user-defined hook if specified
if (-x $conf{load_hook} && open(FILE, "$conf{load_hook}|")) {
    while (my $line = <FILE>) {
        $line =~ s/^\s*(?:#.*)?|\s+$//g;
        if ($line =~ /^(\S+)\s+(.*)/) {
            $load{$1} = $2;
        }
    }
    close FILE;
}

# convert load to single data string
my $data = "#ballast#" . nfreeze(\%load);
if ($conf{data_cipher}) {
    # encrypt data if specified
    $data = $conf{-cbc}->encrypt_hex($data);
} else {
    $data = encode_base64($data, "");
}

# send data to each server specified
foreach my $host (split(/\s+/, $conf{data_host})) {
    eval {
        local $SIG{ALRM} = sub {die "alarm\n"};
        alarm $conf{data_timeout};
        my $sock = IO::Socket::INET->new(
            Proto    => 'tcp',
            PeerAddr => $host,
            PeerPort => $conf{data_port},
        );
        if ($sock) {
            print $sock "#$data\n";
            close $sock;
        } else {
            print STDERR "Unable to contact server $host\n";
        }
    };
    print STDERR "Timed out communicating with server $host\n"
        if ($@ eq "alarm\n");
}
alarm 0;
