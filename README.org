#+TITLE: Acksin Autotune
#+AUTHOR: Acksin
#+OPTIONS: html-postamble:nil body-only: t

#+begin_quote

#+end_quote

* Introduction

Autotune the Linux to get the optimal server performance.

Acksin Autotune makes sure that your Linux servers are utilized as
efficiently as possible. It does this by tuning your Linux kernel
based on various criteria. The type of application profile, memory,
CPUs, instance type to bring out the best performance for your
machine.

* Usage

** Help
#+begin_src sh
autotune --help
#+end_src

#+RESULTS:

** List Signatures

#+begin_src sh :results output code :exports both
autotune list
#+end_src

#+RESULTS:
#+BEGIN_SRC sh
{
  "Open": [
    "fast-server",
    "fs",
    "io",
    "memory",
    "networking"
  ],
  "Startup": [
    "apache",
    "golang",
    "haproxy",
    "nginx",
    "nodejs",
    "postgresql"
  ]
}
#+END_SRC

** Tuning

*** Show Signature

#+begin_src sh :results output code :exports both
autotune sig networking
#+end_src

#+RESULTS:
#+BEGIN_SRC sh
{
  "Name": "networking",
  "Subscription": 0,
  "Description": "Settings for high performance networking",
  "Documentation": "TODO: These setting are sort of set in stone but I feel that they can adapt as the system is being used. We don't have to set them to the values but we can migrate and change as we learn more about the system and tune it appropriately.",
  "References": [
    "http://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html",
    "https://rtcamp.com/tutorials/linux/sysctl-conf/",
    "https://fasterdata.es.net/host-tuning/linux/",
    "http://cherokee-project.com/doc/other_os_tuning.html",
    "https://easyengine.io/tutorials/linux/sysctl-conf/"
  ],
  "Vars": {
    "nfConntrackMax": 200000
  }
}
#+END_SRC

#+RESULTS:

*** ProcFS Changes

 #+begin_src sh :results output code :exports both
 autotune procfs fs
 #+end_src

 #+RESULTS:
 #+BEGIN_SRC sh
 fs.file-max=11160204
 proc.file-max=2097152
 vm.dirty_background_ratio=5
 vm.dirty_expire_centisecs=1200
 vm.dirty_ratio=80
 #+END_SRC

 #+RESULTS:

*** SysFS Changes

 #+begin_src sh :results output code :exports both
 autotune sysfs io
 #+end_src

 #+RESULTS:
 #+BEGIN_SRC sh
 /sys/block/*/queue/read_ahead_kb=256
 /sys/block/*/queue/rq_afinity=2
 /sys/block/*/queue/scheduler=noop
 #+END_SRC

 #+RESULTS:

*** Environment Variable Changes

 #+begin_src sh :results output code :exports both
 autotune env golang
 #+end_src

 #+RESULTS:
 #+BEGIN_SRC sh
#+END_SRC

 #+RESULTS:

* Open Signatures

#+begin_src ruby :results output drawer :exports results
  require 'json'

  sigs = JSON.parse(`./autotune list`)

  sigs["Open"].each do |s|
    sigInfo = JSON.parse(`./autotune sig #{s}`)

    puts "** #{sigInfo["Name"]}"
    puts
    puts sigInfo["Documentation"]
    puts

    ["ProcFS", "SysFS", "Env"].each do |type|
      if !!sigInfo[type]
        puts "*** #{type}"
        puts
        puts "#+ATTR_HTML: :class table"
        puts "|#{type} Key|Value|Description|"
        puts "| <10> | <8> |||" if type == "Env"
        sigInfo[type].each do |k, v|
          puts "|=#{k}=|=#{v["Value"] rescue ""}=|#{v["Description"].gsub("\n", ' ') rescue ""}|"
        end
      end
    end

    if !!sigInfo["Deps"] && !sigInfo["Deps"].empty?
      puts "*** Dependencies"
      puts
      sigInfo["Deps"].each do |k|
        puts " - [[#{k}][#{k}]]"
      end
      puts
    end

    if !!sigInfo["References"] && !sigInfo["References"].empty?
      puts "*** References"
      puts
      sigInfo["References"].each do |k|
        puts " - [[#{k}][#{k}]]"
      end
      puts
    end
  end
#+end_src

#+RESULTS:
:RESULTS:
** fast-server



*** ProcFS

#+ATTR_HTML: :class table
|ProcFS Key|Value|Description|
|=fs.file-max=|=11160204=||
|=net.core.netdev_max_backlog=|=30000=|The number of incoming connections on the backlog queue. The maximum number of packets queued on the INPUT side.|
|=net.core.rmem_max=|=16777216=|The size of the receive buffer for all the sockets. 16MB per socket.|
|=net.core.somaxconn=|=16096=|The maximum number of queued sockets on a connection.|
|=net.core.wmem_max=|=16777216=|The size of the buffer for all the sockets. 16MB per socket.|
|=net.ipv4.ip_local_port_range=|=1024 65535=|On a typical machine there are around 28000 ports available to be bound to. This number can get exhausted quickly if there are many connections. We will increase this.|
|=net.ipv4.tcp_fin_timeout=|=15=|Usually, the Linux kernel holds a TCP connection even after it is closed for around two minutes. This means that there may be a port exhaustion as the kernel waits to close the connections. By moving the fin_timeout to 15 seconds we drastically reduce the length of time the kernel is waiting for the socket to get any remaining packets.|
|=net.ipv4.tcp_max_syn_backlog=|=20480=|Increase the number syn requests allowed. Sets how many half-open connections to backlog queue|
|=net.ipv4.tcp_max_tw_buckets=|=400000=|Increase the tcp-time-wait buckets pool size to prevent simple DOS attacks|
|=net.ipv4.tcp_no_metrics_save=|=1=|TCP saves various connection metrics in the route cache when the connection closes so that connections established in the near future can use these to set initial conditions. Usually, this increases overall performance, but may sometimes cause performance degradation.|
|=net.ipv4.tcp_rmem=|=4096 87380 16777216=|(min, default, max): The sizes of the receive buffer for the IP protocol.|
|=net.ipv4.tcp_syn_retries=|=2=|Number of times initial SYNs for a TCP connection attempt will be retransmitted for outgoing connections.|
|=net.ipv4.tcp_synack_retries=|=2=|This setting determines the number of SYN+ACK packets sent before the kernel gives up on the connection|
|=net.ipv4.tcp_syncookies=|=1=|Security to prevent DDoS attacks. http://cr.yp.to/syncookies.html|
|=net.ipv4.tcp_wmem=|=4096 65536 16777216=|(min, default, max): The sizes of the write buffer for the IP protocol.|
|=net.netfilter.nf_conntrack_max=|=200000=|The max is double the previous value. https://wiki.khnet.info/index.php/Conntrack_tuning|
|=proc.file-max=|=2097152=|The max amount of file handlers that the Linux kernel will allocate. This is one part the other part is setting the ulimits.|
|=proc.min_free_kbytes=|=65536=|Amount of memory to keep free. Don't want to make this too high as Linux will spend more time trying to reclaim memory.|
|=vm.dirty_background_ratio=|=5=||
|=vm.dirty_expire_centisecs=|=1200=||
|=vm.dirty_ratio=|=80=||
|=vm.swappiness=|=0=| Disable swapping and clear the file system page cache to free memory first.|
*** SysFS

#+ATTR_HTML: :class table
|SysFS Key|Value|Description|
|=/sys/block/*/queue/read_ahead_kb=|=256=||
|=/sys/block/*/queue/rq_afinity=|=2=||
|=/sys/block/*/queue/scheduler=|=noop=||
|=/sys/kernel/mm/transparent_hugepage/enabled=|=always=|Explit huge page usage making the page size of 2 or 4 MB instead of 4kb. Should reduce CPU overhead and improve MMU page translation.|
|=/sys/module/nf_conntrack/parameters/hashsize=|=50000=||
** fs



*** ProcFS

#+ATTR_HTML: :class table
|ProcFS Key|Value|Description|
|=fs.file-max=|=11160204=||
|=proc.file-max=|=2097152=|The max amount of file handlers that the Linux kernel will allocate. This is one part the other part is setting the ulimits.|
|=vm.dirty_background_ratio=|=5=||
|=vm.dirty_expire_centisecs=|=1200=||
|=vm.dirty_ratio=|=80=||
*** References

 - [[https://tweaked.io/guide/kernel/][https://tweaked.io/guide/kernel/]]
 - [[http://blog.neutrino.es/2013/howto-properly-activate-trim-for-your-ssd-on-linux-fstrim-lvm-and-dmcrypt/][http://blog.neutrino.es/2013/howto-properly-activate-trim-for-your-ssd-on-linux-fstrim-lvm-and-dmcrypt/]]

** io



*** SysFS

#+ATTR_HTML: :class table
|SysFS Key|Value|Description|
|=/sys/block/*/queue/read_ahead_kb=|=256=||
|=/sys/block/*/queue/rq_afinity=|=2=||
|=/sys/block/*/queue/scheduler=|=noop=||
*** References

 - [[http://www.brendangregg.com/linuxperf.html][http://www.brendangregg.com/linuxperf.html]]

** memory



*** ProcFS

#+ATTR_HTML: :class table
|ProcFS Key|Value|Description|
|=proc.min_free_kbytes=|=65536=|Amount of memory to keep free. Don't want to make this too high as Linux will spend more time trying to reclaim memory.|
|=vm.swappiness=|=0=| Disable swapping and clear the file system page cache to free memory first.|
*** SysFS

#+ATTR_HTML: :class table
|SysFS Key|Value|Description|
|=/sys/kernel/mm/transparent_hugepage/enabled=|=always=|Explit huge page usage making the page size of 2 or 4 MB instead of 4kb. Should reduce CPU overhead and improve MMU page translation.|
** networking

TODO: These setting are sort of set in stone but I feel that they can adapt as the system is being used. We don't have to set them to the values but we can migrate and change as we learn more about the system and tune it appropriately.

*** ProcFS

#+ATTR_HTML: :class table
|ProcFS Key|Value|Description|
|=net.core.netdev_max_backlog=|=30000=|The number of incoming connections on the backlog queue. The maximum number of packets queued on the INPUT side.|
|=net.core.rmem_max=|=16777216=|The size of the receive buffer for all the sockets. 16MB per socket.|
|=net.core.somaxconn=|=16096=|The maximum number of queued sockets on a connection.|
|=net.core.wmem_max=|=16777216=|The size of the buffer for all the sockets. 16MB per socket.|
|=net.ipv4.ip_local_port_range=|=1024 65535=|On a typical machine there are around 28000 ports available to be bound to. This number can get exhausted quickly if there are many connections. We will increase this.|
|=net.ipv4.tcp_fin_timeout=|=15=|Usually, the Linux kernel holds a TCP connection even after it is closed for around two minutes. This means that there may be a port exhaustion as the kernel waits to close the connections. By moving the fin_timeout to 15 seconds we drastically reduce the length of time the kernel is waiting for the socket to get any remaining packets.|
|=net.ipv4.tcp_max_syn_backlog=|=20480=|Increase the number syn requests allowed. Sets how many half-open connections to backlog queue|
|=net.ipv4.tcp_max_tw_buckets=|=400000=|Increase the tcp-time-wait buckets pool size to prevent simple DOS attacks|
|=net.ipv4.tcp_no_metrics_save=|=1=|TCP saves various connection metrics in the route cache when the connection closes so that connections established in the near future can use these to set initial conditions. Usually, this increases overall performance, but may sometimes cause performance degradation.|
|=net.ipv4.tcp_rmem=|=4096 87380 16777216=|(min, default, max): The sizes of the receive buffer for the IP protocol.|
|=net.ipv4.tcp_syn_retries=|=2=|Number of times initial SYNs for a TCP connection attempt will be retransmitted for outgoing connections.|
|=net.ipv4.tcp_synack_retries=|=2=|This setting determines the number of SYN+ACK packets sent before the kernel gives up on the connection|
|=net.ipv4.tcp_syncookies=|=1=|Security to prevent DDoS attacks. http://cr.yp.to/syncookies.html|
|=net.ipv4.tcp_wmem=|=4096 65536 16777216=|(min, default, max): The sizes of the write buffer for the IP protocol.|
|=net.netfilter.nf_conntrack_max=|=200000=|The max is double the previous value. https://wiki.khnet.info/index.php/Conntrack_tuning|
*** SysFS

#+ATTR_HTML: :class table
|SysFS Key|Value|Description|
|=/sys/module/nf_conntrack/parameters/hashsize=|=50000=||
*** References

 - [[http://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html][http://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html]]
 - [[https://rtcamp.com/tutorials/linux/sysctl-conf/][https://rtcamp.com/tutorials/linux/sysctl-conf/]]
 - [[https://fasterdata.es.net/host-tuning/linux/][https://fasterdata.es.net/host-tuning/linux/]]
 - [[http://cherokee-project.com/doc/other_os_tuning.html][http://cherokee-project.com/doc/other_os_tuning.html]]
 - [[https://easyengine.io/tutorials/linux/sysctl-conf/][https://easyengine.io/tutorials/linux/sysctl-conf/]]

:END:
